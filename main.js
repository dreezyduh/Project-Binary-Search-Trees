/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ (() => {

eval("class Node {\r\n  constructor(data) {\r\n    this.data = data;\r\n    this.left = null;\r\n    this.right = null;\r\n  }\r\n}\r\n\r\nclass Tree {\r\n  constructor(root = null) {\r\n    this.root = root;\r\n  }\r\n\r\n  buildTree(array, start, end) {\r\n    if (start > end) return null;\r\n\r\n    const mid = Math.floor((start + end) / 2);\r\n    const node = new Node(array[mid]);\r\n\r\n    node.left = this.buildTree(array, start, mid - 1);\r\n    node.right = this.buildTree(array, mid + 1, end);\r\n\r\n    return (this.root = node);\r\n  }\r\n\r\n  insert(value) {\r\n    let tmp = this.root;\r\n\r\n    while (value === tmp.data) return console.log('Value already inside tree');\r\n\r\n    while (tmp !== null) {\r\n      if (value < tmp.data) {\r\n        if (tmp.left === null) {\r\n          tmp.left = new Node(value);\r\n          break;\r\n        }\r\n        tmp = tmp.left;\r\n      } else {\r\n        if (tmp.right === null) {\r\n          tmp.right = new Node(value);\r\n          break;\r\n        }\r\n        tmp = tmp.right;\r\n      }\r\n    }\r\n    this.print();\r\n  }\r\n\r\n  deleteItem(root, value) {\r\n    if (root === null) return root;\r\n\r\n    if (value < root.data) {\r\n      root.left = this.deleteItem(root.left, value);\r\n    } else if (value > root.data) {\r\n      root.right = this.deleteItem(root.right, value);\r\n    } else {\r\n      if (root.left === null) return root.right;\r\n      else if (root.right === null) return root.left;\r\n      root.data = this.smallestItem(root.right);\r\n      root.right = this.deleteItem(root.right, root.data);\r\n    }\r\n    return root;\r\n  }\r\n\r\n  find(value) {\r\n    let root = this.root;\r\n\r\n    if (root === null) return `Node is empty`;\r\n\r\n    while (root !== null) {\r\n      if (value < root.data) {\r\n        root = root.left;\r\n      } else if (value > root.data) {\r\n        root = root.right;\r\n      } else if (value === root.data) {\r\n        return root;\r\n      }\r\n    }\r\n    return 'No value found inside node';\r\n  }\r\n\r\n  smallestItem(node) {\r\n    let small = node.data;\r\n    while (node.left !== null) {\r\n      small = node.left.data;\r\n      node = node.left;\r\n    }\r\n    return small;\r\n  }\r\n\r\n  shoutData(node) {\r\n    console.log(node.data + '!!! ');\r\n  }\r\n\r\n  levelOrder(callback, root = this.root) {\r\n    if (root === null) return;\r\n    let queue = [];\r\n    let valueArray = [];\r\n    queue.push(root);\r\n    while (queue.length > 0) {\r\n      let cur = queue[0];\r\n      if (callback === undefined) {\r\n        valueArray.push(cur.data);\r\n      } else {\r\n        callback(cur);\r\n      }\r\n      if (cur.left !== null) queue.push(cur.left);\r\n      if (cur.right !== null) queue.push(cur.right);\r\n      queue.splice(0, 1);\r\n    }\r\n    if (callback === undefined) {\r\n      console.log(valueArray);\r\n      return valueArray;\r\n    }\r\n  }\r\n\r\n  inOrder(root = this.root, arr = [], callback) {\r\n    if (root === null) return;\r\n    if (callback !== undefined) {\r\n      callback(root);\r\n    }\r\n    this.inOrder(root.left, arr, callback);\r\n    arr.push(root.data);\r\n    this.inOrder(root.right, arr, callback);\r\n    if (callback === undefined) {\r\n      return arr;\r\n    }\r\n  }\r\n\r\n  preOrder(root = this.root, arr = [], callback) {\r\n    if (root === null) return;\r\n    if (callback !== undefined) {\r\n      callback(root);\r\n    }\r\n    arr.push(root.data);\r\n    this.preOrder(root.left, arr, callback);\r\n    this.preOrder(root.right, arr, callback);\r\n    if (callback === undefined) {\r\n      return arr;\r\n    }\r\n  }\r\n\r\n  postOrder(root = this.root, arr = [], callback) {\r\n    if (root === null) return;\r\n    if (callback !== undefined) {\r\n      callback(root);\r\n    }\r\n    this.postOrder(root.left, arr, callback);\r\n    this.postOrder(root.right, arr, callback);\r\n    arr.push(root.data);\r\n    if (callback === undefined) {\r\n      return arr;\r\n    }\r\n  }\r\n\r\n  print() {\r\n    prettyPrint(this.root);\r\n    console.log(this.root);\r\n  }\r\n\r\n  height(node = this.root) {\r\n    if (node === null) return 0;\r\n    const leftHeight = this.height(node.left);\r\n    const rightHeight = this.height(node.right);\r\n    return Math.max(leftHeight, rightHeight) + 1;\r\n  }\r\n\r\n  depth(node = this.root) {\r\n    let root = this.root;\r\n    let depth = 0;\r\n    while (root !== null && root.data !== node.data) {\r\n      if (node.data < root.data) {\r\n        root = root.left;\r\n      } else if (node.data > root.data) {\r\n        root = root.right;\r\n      }\r\n      depth++;\r\n    }\r\n\r\n    while (root === null) return;\r\n\r\n    return depth;\r\n  }\r\n\r\n  isBalanced(root = this.root) {\r\n    const leftHeight = this.height(root.left);\r\n    const rightHeight = this.height(root.right);\r\n    const diff = Math.abs(leftHeight - rightHeight);\r\n    return diff > 1 ? false : true;\r\n  }\r\n\r\n  rebalance(root = this.root) {\r\n    let arr = this.levelOrder(...Array(1), root);\r\n    arr.sort((a, b) => a - b);\r\n    this.buildTree(arr, 0, arr.length - 1);\r\n  }\r\n}\r\n\r\nconst prettyPrint = (node, prefix = '', isLeft = true) => {\r\n  if (node === null) {\r\n    return;\r\n  }\r\n  if (node.right !== null) {\r\n    prettyPrint(node.right, `${prefix}${isLeft ? '│   ' : '    '}`, false);\r\n  }\r\n  console.log(`${prefix}${isLeft ? '└── ' : '┌── '}${node.data}`);\r\n  if (node.left !== null) {\r\n    prettyPrint(node.left, `${prefix}${isLeft ? '    ' : '│   '}`, true);\r\n  }\r\n};\r\n\r\nfunction mergeSort(nums) {\r\n  const length = nums.length;\r\n  if (length <= 1) return nums;\r\n  const mid = Math.round(length / 2);\r\n  const leftArray = nums.slice(0, mid);\r\n  const rightArray = nums.slice(mid);\r\n  mergeSort(leftArray);\r\n  mergeSort(rightArray);\r\n  return merge(leftArray, rightArray, nums);\r\n}\r\n\r\nfunction merge(leftArr, rightArr, mergeArr) {\r\n  const leftSize = leftArr.length;\r\n  const rightSize = rightArr.length;\r\n  let l = 0;\r\n  r = 0;\r\n  m = 0;\r\n  while (l < leftSize && r < rightSize) {\r\n    if (leftArr[l] < rightArr[r]) {\r\n      mergeArr[m] = leftArr[l];\r\n      m++;\r\n      l++;\r\n    } else {\r\n      mergeArr[m] = rightArr[r];\r\n      m++;\r\n      r++;\r\n    }\r\n  }\r\n  while (l < leftSize) {\r\n    mergeArr[m] = leftArr[l];\r\n    l++;\r\n    m++;\r\n  }\r\n  while (r < rightSize) {\r\n    mergeArr[m] = rightArr[r];\r\n    r++;\r\n    m++;\r\n  }\r\n  return mergeArr;\r\n}\r\n\r\nfunction removeDupes(arr) {\r\n  let unique = arr.reduce(function (acc, curr) {\r\n    if (!acc.includes(curr)) acc.push(curr);\r\n    return acc;\r\n  }, []);\r\n  return unique;\r\n}\r\n\r\n// Driver script //\r\n\r\nfunction randomArray(size) {\r\n  let arr = [];\r\n  for (let i = 0; i < size; i++) {\r\n    const n = Math.floor(Math.random() * 100);\r\n    if (!arr.includes(n)) {\r\n      arr.push(n);\r\n    } else i--;\r\n  }\r\n  arr.sort((a, b) => a - b);\r\n  return arr;\r\n}\r\n\r\nfunction driverTree() {\r\n  const driver = new Tree();\r\n  const driverArr = randomArray(10);\r\n  driver.buildTree(driverArr, 0, driverArr.length - 1);\r\n  driver.print();\r\n  console.log('Is tree balanced ? ' + driver.isBalanced());\r\n  driver.levelOrder();\r\n  console.log(driver.preOrder());\r\n  console.log(driver.postOrder());\r\n  console.log(driver.inOrder());\r\n  driver.insert(101);\r\n  driver.insert(239);\r\n  driver.insert(405);\r\n  driver.insert(534);\r\n  console.log('Is tree balanced ? ' + driver.isBalanced());\r\n  driver.rebalance();\r\n  driver.print();\r\n  console.log('Is tree balanced ? ' + driver.isBalanced());\r\n  driver.levelOrder();\r\n  console.log(driver.preOrder());\r\n  console.log(driver.postOrder());\r\n  console.log(driver.inOrder());\r\n}\r\n\r\n//   const tree = new Tree();\r\n//   let treeArray = mergeSort([1, 7, 4, 23, 8, 9, 4, 3, 5, 7, 9, 67, 6345, 324]);\r\n//   console.log(treeArray)\r\n//   treeArray = removeDupes(treeArray);\r\n//   console.log(treeArray)\r\n//   const length = treeArray.length;\r\n//   tree.buildTree(treeArray, 0, length - 1);\r\n//   tree.print();\r\n//   tree.insert(0);\r\n//   tree.insert(100);\r\n//   tree.insert(10);\r\n//   tree.insert(200);\r\n//   tree.insert(7000);\r\n//   tree.deleteItem(tree.root, 8)\r\n//   tree.print();\r\n//   tree.levelOrder()\r\n//   console.log(tree.preOrder())\r\n//   console.log(tree.inOrder())\r\n//   console.log(tree.postOrder())\r\n//   console.log(tree.height())\r\n//   console.log(tree.isBalanced())\r\n//   console.log(tree.rebalance())\r\n//   tree.print();\r\n\r\ndriverTree();\r\n\n\n//# sourceURL=webpack://todolist/./src/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/index.js"]();
/******/ 	
/******/ })()
;